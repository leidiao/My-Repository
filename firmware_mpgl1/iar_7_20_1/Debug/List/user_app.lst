###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        08/Jun/2016  11:54:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpg_common\application\user_app.c
#    Command line =  
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpg_common\application\user_app.c
#        -D MPGL1 -D MPG1 --preprocess=cl
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\ -o
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        E:\EIE\arm\INC\c\DLib_Config_Normal.h -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\ -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I E:\EIE\arm\CMSIS\Include\
#    List file    =  
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\user_app.lst
#    Object file  =  
#        E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\user_app.o
#
###############################################################################

E:\EIE\EiE\MASTER\Razor_Atmel\firmware_mpg_common\application\user_app.c
      1          /**********************************************************************************************************************
      2          File: user_app.c                                                                
      3          
      4          ----------------------------------------------------------------------------------------------------------------------
      5          To start a new task using this user_app as a template:
      6           1. Copy both user_app.c and user_app.h to the Application directory
      7           2. Rename the files yournewtaskname.c and yournewtaskname.h
      8           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
      9           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app" with "yournewtaskname"
     10           5. Use ctrl-h to find and replace all instances of "UserApp" with "YourNewTaskName"
     11           6. Use ctrl-h to find and replace all instances of "USER_APP" with "YOUR_NEW_TASK_NAME"
     12           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     13           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     14           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     15          10. Delete this text (between the dashed lines) and update the Description below to describe your task
     16          ----------------------------------------------------------------------------------------------------------------------
     17          
     18          Description:
     19          This is a user_app.c file template 
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          Public functions:
     25          
     26          
     27          Protected System functions:
     28          void UserAppInitialize(void)
     29          Runs required initialzation for the task.  Should only be called once in main init section.
     30          
     31          void UserAppRunActiveState(void)
     32          Runs current task state.  Should only be called once in main loop.
     33          
     34          
     35          **********************************************************************************************************************/
     36          
     37          #include "configuration.h"
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_"
     42          ***********************************************************************************************************************/
     43          /* New variables */

   \                                 In section .bss, align 4
     44          volatile u32 G_u32UserAppFlags;                       /* Global state flags */
   \                     G_u32UserAppFlags:
   \   00000000                      DS8 4
     45          
     46          
     47          /*--------------------------------------------------------------------------------------------------------------------*/
     48          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     49          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     50          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     51          
     52          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     53          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     54          
     55          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     56          extern AntSetupDataType G_stAntSetupData;                         /* From ant.c */
     57          
     58          extern u32 G_u32AntApiCurrentDataTimeStamp;                       /* From ant_api.c */
     59          extern AntApplicationMessageType G_eAntApiCurrentMessageClass;    /* From ant_api.c */
     60          extern u8 G_au8AntApiCurrentData[ANT_APPLICATION_MESSAGE_BYTES];  /* From ant_api.c */
     61          
     62          /***********************************************************************************************************************
     63          Global variable definitions with scope limited to this local application.
     64          Variable names shall start with "UserApp_" and be declared as static.
     65          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     66          static fnCode_type UserApp_StateMachine;            /* The state machine function pointer */
   \                     UserApp_StateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     67          static u32 UserApp_u32Timeout;                      /* Timeout counter used across states */
   \                     UserApp_u32Timeout:
   \   00000000                      DS8 4
     68          
     69          
     70          /**********************************************************************************************************************
     71          Function Definitions
     72          **********************************************************************************************************************/
     73          
     74          /*--------------------------------------------------------------------------------------------------------------------*/
     75          /* Public functions                                                                                                   */
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          
     78          
     79          /*--------------------------------------------------------------------------------------------------------------------*/
     80          /* Protected functions                                                                                                */
     81          /*--------------------------------------------------------------------------------------------------------------------*/
     82          
     83          /*--------------------------------------------------------------------------------------------------------------------
     84          Function: UserAppInitialize
     85          
     86          Description:
     87          Initializes the State Machine and its variables.
     88          
     89          Requires:
     90            -
     91          
     92          Promises:
     93            - 
     94          */

   \                                 In section .text, align 2, keep-with-next
     95          void UserAppInitialize(void)
     96          {
   \                     UserAppInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     97            /* Clear screen and place start messages */
     98            LCDCommand(LCD_CLEAR_CMD);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       LCDCommand
     99            
    100           /* Configure ANT for this application */
    101            G_stAntSetupData.AntChannel          = ANT_CHANNEL_USERAPP;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable5
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    102            G_stAntSetupData.AntSerialLo         = ANT_SERIAL_LO_USERAPP;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable5
   \   00000012   0x70C8             STRB     R0,[R1, #+3]
    103            G_stAntSetupData.AntSerialHi         = ANT_SERIAL_HI_USERAPP;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable5
   \   00000018   0x7108             STRB     R0,[R1, #+4]
    104            G_stAntSetupData.AntDeviceType       = ANT_DEVICE_TYPE_USERAPP;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable5
   \   0000001E   0x7148             STRB     R0,[R1, #+5]
    105            G_stAntSetupData.AntTransmissionType = ANT_TRANSMISSION_TYPE_USERAPP;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable5
   \   00000024   0x7188             STRB     R0,[R1, #+6]
    106            G_stAntSetupData.AntChannelPeriodLo  = ANT_CHANNEL_PERIOD_LO_USERAPP;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable5
   \   0000002A   0x71C8             STRB     R0,[R1, #+7]
    107            G_stAntSetupData.AntChannelPeriodHi  = ANT_CHANNEL_PERIOD_HI_USERAPP;
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x....             LDR.N    R1,??DataTable5
   \   00000030   0x7208             STRB     R0,[R1, #+8]
    108            G_stAntSetupData.AntFrequency        = ANT_FREQUENCY_USERAPP;
   \   00000032   0x2032             MOVS     R0,#+50
   \   00000034   0x....             LDR.N    R1,??DataTable5
   \   00000036   0x7248             STRB     R0,[R1, #+9]
    109            G_stAntSetupData.AntTxPower          = ANT_TX_POWER_USERAPP;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable5
   \   0000003C   0x7288             STRB     R0,[R1, #+10]
    110            
    111            /* If good initialization, set state to Idle */
    112            if( AntChannelConfig(ANT_SLAVE) )
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       AntChannelConfig
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD004             BEQ.N    ??UserAppInitialize_0
    113            {
    114              UserApp_StateMachine = UserAppSM_Idle;
   \   00000048   0x.... 0x....      ADR.W    R0,UserAppSM_Idle
   \   0000004C   0x....             LDR.N    R1,??DataTable5_1
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   \   00000050   0xE003             B.N      ??UserAppInitialize_1
    115            }
    116            else
    117            {
    118              UserApp_StateMachine = UserAppSM_Error;
   \                     ??UserAppInitialize_0: (+1)
   \   00000052   0x.... 0x....      ADR.W    R0,UserAppSM_Error
   \   00000056   0x....             LDR.N    R1,??DataTable5_1
   \   00000058   0x6008             STR      R0,[R1, #+0]
    119            }
    120          } /* end UserAppInitialize() */
   \                     ??UserAppInitialize_1: (+1)
   \   0000005A   0xBD01             POP      {R0,PC}          ;; return
    121          
    122          
    123          /*----------------------------------------------------------------------------------------------------------------------
    124          Function UserAppRunActiveState()
    125          
    126          Description:
    127          Selects and runs one iteration of the current state in the state machine.
    128          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    129          may take 1ms / n to execute.
    130          
    131          Requires:
    132            - State machine function pointer points at current state
    133          
    134          Promises:
    135            - Calls the function to pointed by the state machine function pointer
    136          */

   \                                 In section .text, align 2, keep-with-next
    137          void UserAppRunActiveState(void)
    138          {
   \                     UserAppRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139            UserApp_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable5_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    140          
    141          } /* end UserAppRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    142          
    143          
    144          /*--------------------------------------------------------------------------------------------------------------------*/
    145          /* Private functions                                                                                                  */
    146          /*--------------------------------------------------------------------------------------------------------------------*/
    147          
    148          
    149          /**********************************************************************************************************************
    150          State Machine Function Definitions
    151          **********************************************************************************************************************/
    152          
    153          /*-------------------------------------------------------------------------------------------------------------------*/
    154          /* Wait for a message to be queued */

   \                                 In section .text, align 4, keep-with-next
    155          static void UserAppSM_Idle(void)
    156          {
   \                     UserAppSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    157            /* Look for BUTTON 0 to open channel */
    158            if(WasButtonPressed(BUTTON0))
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WasButtonPressed
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??UserAppSM_Idle_0
    159            {
    160              /* Got the button, so complete one-time actions before next state */
    161              ButtonAcknowledge(BUTTON0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       ButtonAcknowledge
    162              
    163              /* Queue open channel and change LED0 from yellow to blinking green to indicate channel is opening */
    164              AntOpenChannel();
   \   00000012   0x.... 0x....      BL       AntOpenChannel
    165              
    166              /* Set timer and advance states */
    167              UserApp_u32Timeout = G_u32SystemTime1ms;
   \   00000016   0x....             LDR.N    R0,??DataTable5_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable5_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    168              UserApp_StateMachine = UserAppSM_WaitChannelOpen;
   \   0000001E   0x.... 0x....      ADR.W    R0,UserAppSM_WaitChannelOpen
   \   00000022   0x....             LDR.N    R1,??DataTable5_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    169          
    170            }  
    171          } /* end UserAppSM_Idle() */
   \                     ??UserAppSM_Idle_0: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    172          
    173          
    174          /*-------------------------------------------------------------------------------------------------------------------*/
    175          /* Wait for Channel Open*/

   \                                 In section .text, align 4, keep-with-next
    176          static void UserAppSM_WaitChannelOpen(void)        
    177          {
   \                     UserAppSM_WaitChannelOpen: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    178            /* Monitor the channel status to check if channel is opened */
    179            if(AntRadioStatus() == ANT_OPEN)
   \   00000002   0x.... 0x....      BL       AntRadioStatus
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD103             BNE.N    ??UserAppSM_WaitChannelOpen_0
    180            {
    181              UserApp_StateMachine = UserAppSM_ChannelOpen;
   \   0000000A   0x.... 0x....      ADR.W    R0,UserAppSM_ChannelOpen
   \   0000000E   0x....             LDR.N    R1,??DataTable5_1
   \   00000010   0x6008             STR      R0,[R1, #+0]
    182            }
    183            
    184            /* Check for timeout */
    185            if( IsTimeUp(&UserApp_u32Timeout, TIMEOUT_VALUE) )
   \                     ??UserAppSM_WaitChannelOpen_0: (+1)
   \   00000012   0xF247 0x5130      MOVW     R1,#+30000
   \   00000016   0x....             LDR.N    R0,??DataTable5_3
   \   00000018   0x.... 0x....      BL       IsTimeUp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??UserAppSM_WaitChannelOpen_1
    186            {
    187              AntCloseChannel();
   \   00000020   0x.... 0x....      BL       AntCloseChannel
    188              UserApp_StateMachine = UserAppSM_Idle;
   \   00000024   0x....             LDR.N    R0,??DataTable5_4
   \   00000026   0x....             LDR.N    R1,??DataTable5_1
   \   00000028   0x6008             STR      R0,[R1, #+0]
    189            }
    190          
    191          } /* end UserAppSM_WaitChannelOpen */
   \                     ??UserAppSM_WaitChannelOpen_1: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    192          
    193          
    194          /*-------------------------------------------------------------------------------------------------------------------*/
    195          /* Channel is Open */

   \                                 In section .text, align 4, keep-with-next
    196          static void UserAppSM_ChannelOpen(void)        
    197          {
   \                     UserAppSM_ChannelOpen: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    198            static u8 u8LastState = 0xff;
                             ^
Warning[Pe550]: variable "u8LastState" was set but never used
    199            bool bGotNewData;
    200            bool bGotNewTick;
    201            static u8 au8DataContent1[] = "xxxxxxxxxxxxxxxx";
    202            static u8 au8DataContent2[] = "xxxxxxxxxxxxxxxx";
    203            static u8 au8LastAntData[ANT_APPLICATION_MESSAGE_BYTES] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    204            static u8 au8LastAntTick[ANT_APPLICATION_MESSAGE_BYTES] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    205            static u8 u8String1[]="\n\rANT_DATA:";
    206            static u8 u8String2[]="\n\rANT_TICK:";
    207          
    208            /* Look for BUTTON 1 to Close channel */
    209            if(WasButtonPressed(BUTTON1))
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       WasButtonPressed
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??UserAppSM_ChannelOpen_0
    210            {
    211              /* Got the button, so complete one-time actions before next state */
    212              ButtonAcknowledge(BUTTON1);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       ButtonAcknowledge
    213              
    214              /* Queue Close channel */
    215              AntCloseChannel();
   \   00000012   0x.... 0x....      BL       AntCloseChannel
    216              
    217              /* Set timer and advance states */
    218              UserApp_u32Timeout = G_u32SystemTime1ms;
   \   00000016   0x....             LDR.N    R0,??DataTable5_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable5_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    219              UserApp_StateMachine = UserAppSM_WaitChannelClose;
   \   0000001E   0x.... 0x....      ADR.W    R0,UserAppSM_WaitChannelClose
   \   00000022   0x....             LDR.N    R1,??DataTable5_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    220            }   
    221              /* A slave channel can close on its own, so explicitly check channel status */
    222            if(AntRadioStatus() != ANT_OPEN)
   \                     ??UserAppSM_ChannelOpen_0: (+1)
   \   00000026   0x.... 0x....      BL       AntRadioStatus
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD012             BEQ.N    ??UserAppSM_ChannelOpen_1
    223            {
    224              LedOff(BLUE);
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       LedOff
    225              LedBlink(RED, LED_2HZ);
   \   00000034   0x21FA             MOVS     R1,#+250
   \   00000036   0x2007             MOVS     R0,#+7
   \   00000038   0x.... 0x....      BL       LedBlink
    226              u8LastState = 0xff;
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x....             LDR.N    R1,??DataTable5_5
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    227              
    228              UserApp_u32Timeout = G_u32SystemTime1ms;
   \   00000042   0x....             LDR.N    R0,??DataTable5_2
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x....             LDR.N    R1,??DataTable5_3
   \   00000048   0x6008             STR      R0,[R1, #+0]
    229              UserApp_StateMachine = UserAppSM_WaitChannelClose;
   \   0000004A   0x.... 0x....      ADR.W    R0,UserAppSM_WaitChannelClose
   \   0000004E   0x....             LDR.N    R1,??DataTable5_1
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE00A             B.N      ??UserAppSM_ChannelOpen_2
    230            } /* if(AntRadioStatus() != ANT_OPEN) */
    231            else if(AntRadioStatus() == ANT_OPEN)
   \                     ??UserAppSM_ChannelOpen_1: (+1)
   \   00000054   0x.... 0x....      BL       AntRadioStatus
   \   00000058   0x2803             CMP      R0,#+3
   \   0000005A   0xD106             BNE.N    ??UserAppSM_ChannelOpen_2
    232            {
    233              LedOff(RED);
   \   0000005C   0x2007             MOVS     R0,#+7
   \   0000005E   0x.... 0x....      BL       LedOff
    234              LedBlink(BLUE, LED_2HZ);
   \   00000062   0x21FA             MOVS     R1,#+250
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      BL       LedBlink
    235            }
    236            
    237            /* Always check for ANT messages */
    238            if( AntReadData() )
   \                     ??UserAppSM_ChannelOpen_2: (+1)
   \   0000006A   0x.... 0x....      BL       AntReadData
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xF000 0x8091      BEQ.W    ??UserAppSM_ChannelOpen_3
    239            {
    240               /* New data message: check what it is */
    241              if(G_eAntApiCurrentMessageClass == ANT_DATA)
   \   00000074   0x....             LDR.N    R0,??DataTable5_6
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD148             BNE.N    ??UserAppSM_ChannelOpen_4
    242              {
    243                /* Check if the new data is the same as the old data and update as we go */
    244                bGotNewData = FALSE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0004             MOVS     R4,R0
    245                for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000080   0x2600             MOVS     R6,#+0
   \                     ??UserAppSM_ChannelOpen_5: (+1)
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x2E08             CMP      R6,#+8
   \   00000086   0xDA2E             BGE.N    ??UserAppSM_ChannelOpen_6
    246                {
    247                  if(G_au8AntApiCurrentData[i] != au8LastAntData[i])
   \   00000088   0x....             LDR.N    R0,??DataTable5_7
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0x5C30             LDRB     R0,[R6, R0]
   \   0000008E   0x....             LDR.N    R1,??DataTable5_8
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x5C71             LDRB     R1,[R6, R1]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD024             BEQ.N    ??UserAppSM_ChannelOpen_7
    248                  {
    249                    bGotNewData = TRUE;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0004             MOVS     R4,R0
    250                    au8LastAntData[i] = G_au8AntApiCurrentData[i];
   \   0000009C   0x....             LDR.N    R0,??DataTable5_7
   \   0000009E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A0   0x5C30             LDRB     R0,[R6, R0]
   \   000000A2   0x....             LDR.N    R1,??DataTable5_8
   \   000000A4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A6   0x5470             STRB     R0,[R6, R1]
    251          
    252                    au8DataContent1[2 * i] = HexToASCIICharUpper(G_au8AntApiCurrentData[i] / 16);
   \   000000A8   0x....             LDR.N    R0,??DataTable5_7
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0x5C30             LDRB     R0,[R6, R0]
   \   000000AE   0x2110             MOVS     R1,#+16
   \   000000B0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x.... 0x....      BL       HexToASCIICharUpper
   \   000000BA   0x....             LDR.N    R1,??DataTable5_9
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0xF801 0x0016      STRB     R0,[R1, R6, LSL #+1]
    253                    au8DataContent1[2*i+1] = HexToASCIICharUpper(G_au8AntApiCurrentData[i] % 16); 
   \   000000C2   0x....             LDR.N    R0,??DataTable5_7
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x5C31             LDRB     R1,[R6, R0]
   \   000000C8   0x2210             MOVS     R2,#+16
   \   000000CA   0xFB91 0xF0F2      SDIV     R0,R1,R2
   \   000000CE   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0x.... 0x....      BL       HexToASCIICharUpper
   \   000000D8   0x....             LDR.N    R1,??DataTable5_9
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   000000E0   0x7048             STRB     R0,[R1, #+1]
    254                  }
    255                }
   \                     ??UserAppSM_ChannelOpen_7: (+1)
   \   000000E2   0x1C76             ADDS     R6,R6,#+1
   \   000000E4   0xE7CD             B.N      ??UserAppSM_ChannelOpen_5
    256                 if(bGotNewData)
   \                     ??UserAppSM_ChannelOpen_6: (+1)
   \   000000E6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E8   0x2C00             CMP      R4,#+0
   \   000000EA   0xD054             BEQ.N    ??UserAppSM_ChannelOpen_3
    257                {
    258                  /* We got new data: show on LCD */
    259                  LCDClearChars(LINE2_START_ADDR, 20); 
   \   000000EC   0x2114             MOVS     R1,#+20
   \   000000EE   0x2040             MOVS     R0,#+64
   \   000000F0   0x.... 0x....      BL       LCDClearChars
    260                  LCDMessage(LINE2_START_ADDR, au8DataContent1); 
   \   000000F4   0x....             LDR.N    R1,??DataTable5_9
   \   000000F6   0x2040             MOVS     R0,#+64
   \   000000F8   0x.... 0x....      BL       LCDMessage
    261                  DebugPrintf(u8String1);
   \   000000FC   0x....             LDR.N    R0,??DataTable5_10
   \   000000FE   0x.... 0x....      BL       DebugPrintf
    262                  DebugPrintf(au8DataContent1);
   \   00000102   0x....             LDR.N    R0,??DataTable5_9
   \   00000104   0x.... 0x....      BL       DebugPrintf
    263                  DebugLineFeed();
   \   00000108   0x.... 0x....      BL       DebugLineFeed
   \   0000010C   0xE043             B.N      ??UserAppSM_ChannelOpen_3
    264                }
    265          
    266              } /* end if(G_eAntApiCurrentMessageClass == ANT_DATA) */
    267          
    268              else if(G_eAntApiCurrentMessageClass == ANT_TICK)
   \                     ??UserAppSM_ChannelOpen_4: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable5_6
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x2802             CMP      R0,#+2
   \   00000114   0xD13F             BNE.N    ??UserAppSM_ChannelOpen_3
    269              {
    270                /* Check if the new data is the same as the old data and update as we go */
    271                bGotNewTick = FALSE;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x0005             MOVS     R5,R0
    272                for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   0000011A   0x2600             MOVS     R6,#+0
   \                     ??UserAppSM_ChannelOpen_8: (+1)
   \   0000011C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011E   0x2E08             CMP      R6,#+8
   \   00000120   0xDA2E             BGE.N    ??UserAppSM_ChannelOpen_9
    273                {
    274                  if(G_au8AntApiCurrentData[i] != au8LastAntTick[i])
   \   00000122   0x....             LDR.N    R0,??DataTable5_7
   \   00000124   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000126   0x5C30             LDRB     R0,[R6, R0]
   \   00000128   0x....             LDR.N    R1,??DataTable5_11
   \   0000012A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012C   0x5C71             LDRB     R1,[R6, R1]
   \   0000012E   0x4288             CMP      R0,R1
   \   00000130   0xD024             BEQ.N    ??UserAppSM_ChannelOpen_10
    275                  {
    276                    bGotNewTick = TRUE;
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0x0005             MOVS     R5,R0
    277                    au8LastAntTick[i] = G_au8AntApiCurrentData[i];
   \   00000136   0x....             LDR.N    R0,??DataTable5_7
   \   00000138   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013A   0x5C30             LDRB     R0,[R6, R0]
   \   0000013C   0x....             LDR.N    R1,??DataTable5_11
   \   0000013E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000140   0x5470             STRB     R0,[R6, R1]
    278          
    279                    au8DataContent2[2 * i] = HexToASCIICharUpper(G_au8AntApiCurrentData[i] / 16);
   \   00000142   0x....             LDR.N    R0,??DataTable5_7
   \   00000144   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000146   0x5C30             LDRB     R0,[R6, R0]
   \   00000148   0x2110             MOVS     R1,#+16
   \   0000014A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000014E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000150   0x.... 0x....      BL       HexToASCIICharUpper
   \   00000154   0x....             LDR.N    R1,??DataTable5_12
   \   00000156   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000158   0xF801 0x0016      STRB     R0,[R1, R6, LSL #+1]
    280                    au8DataContent2[2*i+1] = HexToASCIICharUpper(G_au8AntApiCurrentData[i] % 16); 
   \   0000015C   0x....             LDR.N    R0,??DataTable5_7
   \   0000015E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000160   0x5C31             LDRB     R1,[R6, R0]
   \   00000162   0x2210             MOVS     R2,#+16
   \   00000164   0xFB91 0xF0F2      SDIV     R0,R1,R2
   \   00000168   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000016C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016E   0x.... 0x....      BL       HexToASCIICharUpper
   \   00000172   0x....             LDR.N    R1,??DataTable5_12
   \   00000174   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000176   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000017A   0x7048             STRB     R0,[R1, #+1]
    281                  }
    282                }
   \                     ??UserAppSM_ChannelOpen_10: (+1)
   \   0000017C   0x1C76             ADDS     R6,R6,#+1
   \   0000017E   0xE7CD             B.N      ??UserAppSM_ChannelOpen_8
    283                 if(bGotNewTick)
   \                     ??UserAppSM_ChannelOpen_9: (+1)
   \   00000180   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000182   0x2D00             CMP      R5,#+0
   \   00000184   0xD007             BEQ.N    ??UserAppSM_ChannelOpen_3
    284                {
    285                  DebugPrintf(u8String2);
   \   00000186   0x....             LDR.N    R0,??DataTable5_13
   \   00000188   0x.... 0x....      BL       DebugPrintf
    286                  DebugPrintf(au8DataContent2);
   \   0000018C   0x....             LDR.N    R0,??DataTable5_12
   \   0000018E   0x.... 0x....      BL       DebugPrintf
    287                  DebugLineFeed();
   \   00000192   0x.... 0x....      BL       DebugLineFeed
    288                }
    289              
    290              }
    291            }
    292            
    293          
    294          } /* UserAppSM_WaitChannelOpen */
   \                     ??UserAppSM_ChannelOpen_3: (+1)
   \   00000196   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 1
   \                     ??u8LastState:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 4
   \                     ??au8DataContent1:
   \   00000000   0x78 0x78          DC8 "xxxxxxxxxxxxxxxx"
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8DataContent2:
   \   00000000   0x78 0x78          DC8 "xxxxxxxxxxxxxxxx"
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x78 0x78    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8LastAntData:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    

   \                                 In section .data, align 4
   \                     ??au8LastAntTick:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    

   \                                 In section .data, align 4
   \                     ??u8String1:
   \   00000000   0x0A 0x0D          DC8 "\012\015ANT_DATA:"
   \              0x41 0x4E    
   \              0x54 0x5F    
   \              0x44 0x41    
   \              0x54 0x41    
   \              0x3A 0x00    

   \                                 In section .data, align 4
   \                     ??u8String2:
   \   00000000   0x0A 0x0D          DC8 "\012\015ANT_TICK:"
   \              0x41 0x4E    
   \              0x54 0x5F    
   \              0x54 0x49    
   \              0x43 0x4B    
   \              0x3A 0x00    
    295            
    296          
    297          /*-------------------------------------------------------------------------------------------------------------------*/
    298          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
    299          static void UserAppSM_WaitChannelClose(void)          
    300          {
   \                     UserAppSM_WaitChannelClose: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    301            /* Monitor the channel status to check if channel is closed */
    302            if(AntRadioStatus() == ANT_CLOSED)
   \   00000002   0x.... 0x....      BL       AntRadioStatus
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xD102             BNE.N    ??UserAppSM_WaitChannelClose_0
    303            {
    304              UserApp_StateMachine = UserAppSM_Idle;
   \   0000000A   0x....             LDR.N    R0,??DataTable5_4
   \   0000000C   0x....             LDR.N    R1,??DataTable5_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    305            }
    306            
    307            /* Check for timeout */
    308            if( IsTimeUp(&UserApp_u32Timeout, TIMEOUT_VALUE) )
   \                     ??UserAppSM_WaitChannelClose_0: (+1)
   \   00000010   0xF247 0x5130      MOVW     R1,#+30000
   \   00000014   0x....             LDR.N    R0,??DataTable5_3
   \   00000016   0x.... 0x....      BL       IsTimeUp
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??UserAppSM_WaitChannelClose_1
    309            {
    310              UserApp_StateMachine = UserAppSM_Error;
   \   0000001E   0x.... 0x....      ADR.W    R0,UserAppSM_Error
   \   00000022   0x....             LDR.N    R1,??DataTable5_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    311            }
    312           
    313          } /* end UserAppSM_Error() */
   \                     ??UserAppSM_WaitChannelClose_1: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    314          
    315          
    316          /*-------------------------------------------------------------------------------------------------------------------*/
    317          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
    318          static void UserAppSM_Error(void)          
    319          {
    320            
    321          } /* end UserAppSM_Error() */
   \                     UserAppSM_Error: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     UserApp_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     UserApp_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     UserAppSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     ??u8LastState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     G_au8AntApiCurrentData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ??au8LastAntData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     ??au8DataContent1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     ??u8String1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     ??au8LastAntTick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     ??au8DataContent2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     ??u8String2
    322          
    323          
    324          /*-------------------------------------------------------------------------------------------------------------------*/
    325          /* State to sit in if init failed */
    326          static void UserAppSM_FailedInit(void)          
                             ^
Warning[Pe177]: function "UserAppSM_FailedInit" was declared but never
          referenced
    327          {
    328              
    329          } /* end UserAppSM_FailedInit() */
    330          
    331          
    332          /*--------------------------------------------------------------------------------------------------------------------*/
    333          /* End of File                                                                                                        */
    334          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserAppInitialize
         8   -> AntChannelConfig
         8   -> LCDCommand
       8   UserAppRunActiveState
         8   -- Indirect call
      16   UserAppSM_ChannelOpen
        16   -> AntCloseChannel
        16   -> AntRadioStatus
        16   -> AntReadData
        16   -> ButtonAcknowledge
        16   -> DebugLineFeed
        16   -> DebugPrintf
        16   -> HexToASCIICharUpper
        16   -> LCDClearChars
        16   -> LCDMessage
        16   -> LedBlink
        16   -> LedOff
        16   -> WasButtonPressed
       0   UserAppSM_Error
       8   UserAppSM_Idle
         8   -> AntOpenChannel
         8   -> ButtonAcknowledge
         8   -> WasButtonPressed
       8   UserAppSM_WaitChannelClose
         8   -> AntRadioStatus
         8   -> IsTimeUp
       8   UserAppSM_WaitChannelOpen
         8   -> AntCloseChannel
         8   -> AntRadioStatus
         8   -> IsTimeUp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  G_u32UserAppFlags
      92  UserAppInitialize
      10  UserAppRunActiveState
     408  UserAppSM_ChannelOpen
       2  UserAppSM_Error
      40  UserAppSM_Idle
      40  UserAppSM_WaitChannelClose
      44  UserAppSM_WaitChannelOpen
       4  UserApp_StateMachine
       4  UserApp_u32Timeout
      20  au8DataContent1
      20  au8DataContent2
       8  au8LastAntData
       8  au8LastAntTick
       1  u8LastState
      12  u8String1
      12  u8String2

 
  12 bytes in section .bss
  81 bytes in section .data
 692 bytes in section .text
 
 692 bytes of CODE memory
  93 bytes of DATA memory

Errors: none
Warnings: 2
